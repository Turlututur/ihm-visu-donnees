import type { CypherEnvironment } from "../Environment";
import { MatchableElement, MatchParams, Pattern } from "../Pattern";
import { Clause } from "./Clause";
import { WithReturn } from "./mixins/WithReturn";
import { WithWhere } from "./mixins/WithWhere";
import { WithSet } from "./mixins/WithSet";
import { WithWith } from "./mixins/WithWith";
import { DeleteInput } from "../sub-clauses/Delete";
import type { PropertyRef } from "../PropertyRef";
export declare class Match<T extends MatchableElement = any> extends Clause {
    private pattern;
    private deleteClause;
    private removeClause;
    constructor(variable: T | Pattern<T>, parameters?: MatchParams<T>, parent?: Clause);
    delete(...deleteInput: DeleteInput): this;
    detachDelete(...deleteInput: DeleteInput): this;
    remove(...properties: PropertyRef[]): this;
    getCypher(env: CypherEnvironment): string;
    private createDeleteClause;
}
export interface Match extends WithReturn, WithWhere, WithSet, WithWith {
}
export declare class OptionalMatch extends Match {
    getCypher(env: CypherEnvironment): string;
}
//# sourceMappingURL=Match.d.ts.map