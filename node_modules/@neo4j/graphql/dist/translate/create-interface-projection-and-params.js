"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils/utils");
const constants_1 = require("../constants");
const filter_interface_nodes_1 = __importDefault(require("../utils/filter-interface-nodes"));
const create_connection_and_params_1 = __importDefault(require("./connection/create-connection-and-params"));
const create_auth_and_params_1 = require("./create-auth-and-params");
const create_projection_and_params_1 = __importDefault(require("./create-projection-and-params"));
const get_relationship_direction_1 = require("../utils/get-relationship-direction");
const create_element_where_and_params_1 = __importDefault(require("./where/create-element-where-and-params"));
const CypherBuilder = __importStar(require("./cypher-builder/CypherBuilder"));
const add_sort_and_limit_to_clause_1 = require("./projection/elements/add-sort-and-limit-to-clause");
const utils_2 = require("./cypher-builder/utils/utils");
function createInterfaceProjectionAndParams({ resolveTree, field, context, nodeVariable, parameterPrefix, withVars, }) {
    let globalParams = {};
    let params = {};
    const fullWithVars = (0, utils_1.removeDuplicates)([...(0, utils_1.asArray)(withVars), nodeVariable]);
    const relTypeStr = `[:${field.type}]`;
    const { inStr, outStr } = (0, get_relationship_direction_1.getRelationshipDirectionStr)(field, resolveTree.args);
    const whereInput = resolveTree.args.where;
    const referenceNodes = context.nodes.filter((x) => field.interface?.implementations?.includes(x.name) && (0, filter_interface_nodes_1.default)({ node: x, whereInput }));
    let whereArgs = {};
    const subqueries = referenceNodes.map((refNode) => {
        const param = `${nodeVariable}_${refNode.name}`;
        const subquery = [
            `WITH ${fullWithVars.join(", ")}`,
            `MATCH (${nodeVariable})${inStr}${relTypeStr}${outStr}(${param}:${refNode.name})`,
        ];
        const allowAndParams = (0, create_auth_and_params_1.createAuthAndParams)({
            operations: "READ",
            entity: refNode,
            context,
            allow: {
                parentNode: refNode,
                varName: param,
            },
        });
        if (allowAndParams[0]) {
            globalParams = { ...globalParams, ...allowAndParams[1] };
            subquery.push(`CALL apoc.util.validate(NOT (${allowAndParams[0]}), "${constants_1.AUTH_FORBIDDEN_ERROR}", [0])`);
        }
        const whereStrs = [];
        if (resolveTree.args.where) {
            // For root filters
            const rootNodeWhereAndParams = (0, create_element_where_and_params_1.default)({
                whereInput: {
                    ...Object.entries(whereInput).reduce((args, [k, v]) => {
                        if (k !== "_on") {
                            // If this where key is also inside _on for this implementation, use the one in _on instead
                            if (whereInput?._on?.[refNode.name]?.[k]) {
                                return args;
                            }
                            return { ...args, [k]: v };
                        }
                        return args;
                    }, {}),
                },
                context,
                element: refNode,
                varName: param,
                parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where`,
            });
            if (rootNodeWhereAndParams[0]) {
                whereStrs.push(rootNodeWhereAndParams[0]);
                whereArgs = { ...whereArgs, ...rootNodeWhereAndParams[1] };
            }
            // For _on filters
            if (whereInput?._on?.[refNode.name]) {
                const onTypeNodeWhereAndParams = (0, create_element_where_and_params_1.default)({
                    whereInput: {
                        ...Object.entries(whereInput).reduce((args, [k, v]) => {
                            if (k !== "_on") {
                                return { ...args, [k]: v };
                            }
                            if (Object.prototype.hasOwnProperty.call(v, refNode.name)) {
                                return { ...args, ...v[refNode.name] };
                            }
                            return args;
                        }, {}),
                    },
                    context,
                    element: refNode,
                    varName: param,
                    parameterPrefix: `${parameterPrefix ? `${parameterPrefix}.` : `${nodeVariable}_`}${resolveTree.alias}.args.where._on.${refNode.name}`,
                });
                if (onTypeNodeWhereAndParams[0]) {
                    whereStrs.push(onTypeNodeWhereAndParams[0]);
                    if (whereArgs._on) {
                        whereArgs._on[refNode.name] = onTypeNodeWhereAndParams[1];
                    }
                    else {
                        whereArgs._on = { [refNode.name]: onTypeNodeWhereAndParams[1] };
                    }
                }
            }
        }
        const whereAuth = (0, create_auth_and_params_1.createAuthAndParams)({
            operations: "READ",
            entity: refNode,
            context,
            where: { varName: param, node: refNode },
        });
        if (whereAuth[0]) {
            whereStrs.push(whereAuth[0]);
            globalParams = { ...globalParams, ...whereAuth[1] };
        }
        if (whereStrs.length) {
            subquery.push(`WHERE ${whereStrs.join(" AND ")}`);
        }
        const { projection: projectionStr, params: projectionParams, meta, subqueries: projectionSubQueries, } = (0, create_projection_and_params_1.default)({
            resolveTree,
            node: refNode,
            context,
            varName: param,
            literalElements: true,
            resolveType: true,
        });
        if (meta?.connectionFields?.length) {
            meta.connectionFields.forEach((connectionResolveTree) => {
                const connectionField = refNode.connectionFields.find((x) => x.fieldName === connectionResolveTree.name);
                const connection = (0, create_connection_and_params_1.default)({
                    resolveTree: connectionResolveTree,
                    field: connectionField,
                    context,
                    nodeVariable: param,
                });
                subquery.push(connection[0]);
                params = { ...params, ...projectionParams };
            });
        }
        if (meta?.interfaceFields?.length) {
            const prevRelationshipFields = [];
            meta.interfaceFields.forEach((interfaceResolveTree) => {
                const relationshipField = refNode.relationFields.find((x) => x.fieldName === interfaceResolveTree.name);
                const interfaceProjection = createInterfaceProjectionAndParams({
                    resolveTree: interfaceResolveTree,
                    field: relationshipField,
                    context,
                    nodeVariable: param,
                    withVars: prevRelationshipFields,
                });
                prevRelationshipFields.push(relationshipField.dbPropertyName || relationshipField.fieldName);
                subquery.push(interfaceProjection.cypher);
                params = { ...params, ...interfaceProjection.params };
            });
        }
        const projectionSubqueryClause = CypherBuilder.concat(...projectionSubQueries);
        return new CypherBuilder.RawCypher((env) => {
            const subqueryStr = (0, utils_2.compileCypherIfExists)(projectionSubqueryClause, env);
            const returnStatement = `RETURN ${projectionStr} AS ${field.fieldName}`;
            return [[...subquery, subqueryStr, returnStatement].join("\n"), {}]; // TODO: pass params here instead of globalParams
        });
    });
    const optionsInput = resolveTree.args.options;
    let withClause;
    if (optionsInput) {
        withClause = new CypherBuilder.With("*");
        (0, add_sort_and_limit_to_clause_1.addSortAndLimitOptionsToClause)({
            optionsInput,
            projectionClause: withClause,
            target: new CypherBuilder.NamedNode(field.fieldName),
        });
    }
    const unionClause = new CypherBuilder.Union(...subqueries);
    const call = new CypherBuilder.Call(unionClause);
    return new CypherBuilder.RawCypher((env) => {
        const subqueryStr = call.getCypher(env);
        const withStr = (0, utils_2.compileCypherIfExists)(withClause, env, { suffix: "\n" });
        let interfaceProjection = [`WITH ${fullWithVars.join(", ")}`, subqueryStr];
        if (field.typeMeta.array) {
            interfaceProjection = [
                `WITH ${fullWithVars.join(", ")}`,
                "CALL {",
                ...interfaceProjection,
                `${withStr}RETURN collect(${field.fieldName}) AS ${field.fieldName}`,
                "}",
            ];
        }
        if (Object.keys(whereArgs).length) {
            params.args = { where: whereArgs };
        }
        return [
            interfaceProjection.join("\n"),
            {
                ...globalParams,
                ...(Object.keys(params).length ? { [`${nodeVariable}_${resolveTree.alias}`]: params } : {}),
            },
        ];
    }).build(`${nodeVariable}_`);
}
exports.default = createInterfaceProjectionAndParams;
//# sourceMappingURL=create-interface-projection-and-params.js.map